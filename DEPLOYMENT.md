# Monoliet Client Portal - Deployment Guide

<!-- Generated by Claude Code on 2026-01-17 - Based on repository analysis -->

This guide provides step-by-step instructions for deploying the Monoliet Client Portal to production.

## Table of Contents

1. [Prerequisites](#prerequisites)
2. [Pre-Deployment Checklist](#pre-deployment-checklist)
3. [Server Setup](#server-setup)
4. [Application Deployment](#application-deployment)
5. [Database Setup](#database-setup)
6. [Nginx Proxy Manager Configuration](#nginx-proxy-manager-configuration)
7. [SSL/TLS Certificate Setup](#ssltls-certificate-setup)
8. [Environment Configuration](#environment-configuration)
9. [Automated Tasks (Cron Jobs)](#automated-tasks-cron-jobs)
10. [Monitoring and Logging](#monitoring-and-logging)
11. [Backup Strategy](#backup-strategy)
12. [Troubleshooting](#troubleshooting)
13. [Scaling Considerations](#scaling-considerations)

---

## Prerequisites

### System Requirements

**Minimum Server Specifications:**
- **CPU:** 2 cores
- **RAM:** 4GB minimum, 8GB recommended
- **Storage:** 20GB minimum, SSD recommended
- **OS:** Ubuntu 22.04 LTS or similar Linux distribution

**Software Requirements:**
- Docker 20.10+
- Docker Compose 2.0+
- Git
- Domain name with DNS access

**Network Requirements:**
- Static IP address or stable dynamic IP
- Ports 80 and 443 accessible from internet
- Outbound HTTPS access for n8n API and email

**Based on:** docker-compose.yml, Dockerfile

---

## Pre-Deployment Checklist

Before deploying, ensure you have:

- [ ] Domain name configured (e.g., `portal.monoliet.cloud`)
- [ ] DNS A record pointing to your server IP
- [ ] n8n instance URL and API key
- [ ] Email SMTP credentials (Gmail or Google Workspace)
- [ ] SSL certificate method decided (Let's Encrypt recommended)
- [ ] Backup strategy planned
- [ ] Monitoring tools ready (optional)

---

## Server Setup

### 1. Update System

```bash
sudo apt update && sudo apt upgrade -y
```

### 2. Install Docker

```bash
# Install Docker
curl -fsSL https://get.docker.com -o get-docker.sh
sudo sh get-docker.sh

# Add your user to docker group
sudo usermod -aG docker $USER

# Install Docker Compose
sudo apt install docker-compose-plugin -y

# Verify installation
docker --version
docker compose version
```

### 3. Configure Firewall

```bash
# Allow SSH (if using UFW)
sudo ufw allow OpenSSH

# Allow HTTP and HTTPS
sudo ufw allow 80/tcp
sudo ufw allow 443/tcp

# Enable firewall
sudo ufw enable

# Check status
sudo ufw status
```

### 4. Create Docker Network

The application requires an external Docker network named "web":

```bash
docker network create web
```

**Based on:** docker-compose.yml:40-42

---

## Application Deployment

### 1. Clone Repository

```bash
# Navigate to your application directory
cd /opt

# Clone the repository
sudo git clone https://github.com/your-org/monoliet-portal.git
cd monoliet-portal

# Set proper ownership
sudo chown -R $USER:$USER /opt/monoliet-portal
```

### 2. Create Environment File

```bash
cp .env.example .env
nano .env
```

### 3. Configure Environment Variables

Edit `.env` with production values (see [Environment Configuration](#environment-configuration) section below for details).

**Critical production settings:**

```env
SECRET_KEY=<generate-strong-secret-key>
DEBUG=False
ALLOWED_HOSTS=portal.monoliet.cloud
CSRF_TRUSTED_ORIGINS=https://portal.monoliet.cloud,https://n8n.monoliet.cloud

DB_NAME=monoliet_clients
DB_USER=monoliet
DB_PASSWORD=<strong-database-password>
DB_HOST=postgres
DB_PORT=5432

EMAIL_HOST=smtp.gmail.com
EMAIL_PORT=587
EMAIL_USE_TLS=True
EMAIL_HOST_USER=info@monoliet.cloud
EMAIL_HOST_PASSWORD=<google-app-password>
DEFAULT_FROM_EMAIL=noreply@monoliet.cloud

N8N_URL=https://n8n.monoliet.cloud
N8N_API_KEY=<your-n8n-api-key>

ENCRYPTION_KEY=<fernet-encryption-key>
```

**Based on:** .env.example:1-36, portal/settings.py

### 4. Generate Security Keys

**Generate Django SECRET_KEY:**

```bash
python3 -c 'from django.core.management.utils import get_random_secret_key; print(get_random_secret_key())'
```

**Generate ENCRYPTION_KEY:**

```bash
python3 -c 'from cryptography.fernet import Fernet; print(Fernet.generate_key().decode())'
```

**Based on:** .env.example:31-35

### 5. Build and Start Containers

```bash
# Build the Django container
docker compose build

# Start all services
docker compose up -d

# Check status
docker compose ps

# View logs
docker compose logs -f
```

**Based on:** docker-compose.yml, Dockerfile

---

## Database Setup

### 1. Wait for PostgreSQL to Initialize

```bash
# Monitor PostgreSQL logs until it's ready
docker compose logs -f postgres
```

Wait for message: `database system is ready to accept connections`

**Based on:** docker-compose.yml:16-20

### 2. Run Database Migrations

```bash
docker compose exec django python manage.py makemigrations
docker compose exec django python manage.py migrate
```

**Based on:** README.md:110-112

### 3. Create Superuser Account

```bash
docker compose exec django python manage.py createsuperuser
```

Enter:
- Username (e.g., `admin`)
- Email address
- Password (strong password required)

**Based on:** README.md:115

### 4. Collect Static Files

```bash
docker compose exec django python manage.py collectstatic --noinput
```

This collects all static files to `/app/staticfiles/` which WhiteNoise will serve.

**Based on:** README.md:118, portal/settings.py:143-145

### 5. Verify Database Connection

```bash
# Access Django shell
docker compose exec django python manage.py shell

# In shell:
>>> from clients.models import Client
>>> Client.objects.count()
0
>>> exit()
```

---

## Nginx Proxy Manager Configuration

### 1. Access Nginx Proxy Manager

Navigate to your Nginx Proxy Manager admin panel (typically at port 81 or your configured admin port).

### 2. Add Proxy Host

**Settings:**
- **Domain Names:** `portal.monoliet.cloud`
- **Scheme:** `http`
- **Forward Hostname / IP:** `monoliet-django`
- **Forward Port:** `8000`
- **Cache Assets:** Yes
- **Block Common Exploits:** Yes
- **Websockets Support:** No (not needed)

**Based on:** README.md:129-134, docker-compose.yml:26-28

### 3. Custom Locations (Optional)

If serving large media files, you can add custom locations for better performance.

---

## SSL/TLS Certificate Setup

### Using Let's Encrypt (Recommended)

**In Nginx Proxy Manager:**

1. Go to your proxy host for `portal.monoliet.cloud`
2. Navigate to **SSL** tab
3. Select **Request a new SSL Certificate**
4. Choose **Let's Encrypt**
5. Check:
   - ✅ Force SSL
   - ✅ HTTP/2 Support
   - ✅ HSTS Enabled
6. Enter your email address
7. Agree to Let's Encrypt ToS
8. Click **Save**

Let's Encrypt will automatically renew certificates before expiration.

**Based on:** README.md:134, portal/settings.py:197-207

### Verify SSL Configuration

```bash
# Test SSL certificate
openssl s_client -connect portal.monoliet.cloud:443 -servername portal.monoliet.cloud

# Check SSL Labs rating (optional)
# Visit: https://www.ssllabs.com/ssltest/analyze.html?d=portal.monoliet.cloud
```

---

## Environment Configuration

### Production Environment Variables

**Django Settings:**

```env
SECRET_KEY=<50+ character random string>
DEBUG=False
ALLOWED_HOSTS=portal.monoliet.cloud
CSRF_TRUSTED_ORIGINS=https://portal.monoliet.cloud,https://n8n.monoliet.cloud
```

**CRITICAL:** Never set `DEBUG=True` in production. This exposes sensitive information.

**Based on:** portal/settings.py:25-36

**Database Configuration:**

```env
DB_NAME=monoliet_clients
DB_USER=monoliet
DB_PASSWORD=<use-strong-password-min-16-chars>
DB_HOST=postgres
DB_PORT=5432
```

**Email Configuration (Gmail/Google Workspace):**

```env
EMAIL_HOST=smtp.gmail.com
EMAIL_PORT=587
EMAIL_USE_TLS=True
EMAIL_HOST_USER=info@monoliet.cloud
EMAIL_HOST_PASSWORD=<google-app-password>
DEFAULT_FROM_EMAIL=noreply@monoliet.cloud
```

**Google App Password Setup:**
1. Go to Google Account settings
2. Security → 2-Step Verification
3. App passwords → Generate new app password
4. Use the generated password in `EMAIL_HOST_PASSWORD`

**Based on:** .env.example:16-22, portal/settings.py:175-181

**n8n Integration:**

```env
N8N_URL=https://n8n.monoliet.cloud
N8N_API_KEY=<your-n8n-api-key>
```

Get n8n API key from your n8n instance settings.

**Based on:** .env.example:24-26, portal/settings.py:210-211

**Encryption Key:**

```env
ENCRYPTION_KEY=<fernet-key-from-generator>
```

**CRITICAL:** Never change this key after credentials are encrypted, or data will be unrecoverable.

**Based on:** .env.example:29, portal/settings.py:214, clients/utils.py:17-62

---

## Automated Tasks (Cron Jobs)

The portal includes management commands that should run periodically via cron.

### 1. Access Crontab

```bash
crontab -e
```

### 2. Add Cron Jobs

**Recommended Schedule:**

```cron
# Sync n8n execution data daily at 2 AM
0 2 * * * cd /opt/monoliet-portal && docker compose exec -T django python manage.py sync_n8n_executions --days=7 >> /var/log/monoliet/sync.log 2>&1

# Send invoice reminders daily at 9 AM
0 9 * * * cd /opt/monoliet-portal && docker compose exec -T django python manage.py send_invoice_reminders >> /var/log/monoliet/reminders.log 2>&1

# Check workflow health every hour
0 * * * * cd /opt/monoliet-portal && docker compose exec -T django python manage.py check_workflow_health --threshold=80 >> /var/log/monoliet/health.log 2>&1

# Backup database daily at 3 AM
0 3 * * * cd /opt/monoliet-portal && ./scripts/backup_database.sh >> /var/log/monoliet/backup.log 2>&1
```

**Based on:** README.md:192-203

### 3. Create Log Directory

```bash
sudo mkdir -p /var/log/monoliet
sudo chown $USER:$USER /var/log/monoliet
```

### 4. Management Command Details

**sync_n8n_executions:**
- Syncs execution data from n8n API
- Updates workflow statistics
- Default: last 7 days (configurable with `--days` flag)

**send_invoice_reminders:**
- Sends payment reminders for upcoming/overdue invoices
- Reminder schedule: 3 days before due, on due date, after due date
- Updates invoice status to "overdue" if past due

**check_workflow_health:**
- Monitors workflow error rates
- Default threshold: 80% success rate (configurable with `--threshold` flag)
- Sends email alerts to admins for failing workflows

**Based on:** clients/management/commands/

---

## Monitoring and Logging

### Application Logs

**View Django logs:**

```bash
# Real-time logs
docker compose logs -f django

# Last 100 lines
docker compose logs --tail=100 django

# Export logs to file
docker compose logs django > django_logs.txt
```

**View PostgreSQL logs:**

```bash
docker compose logs -f postgres
```

**View all logs:**

```bash
docker compose logs -f
```

### Log Files

**Django application logs:**
- Location: Docker container stdout/stderr
- Access via: `docker compose logs django`

**Cron job logs:**
- Location: `/var/log/monoliet/*.log`
- Files: `sync.log`, `reminders.log`, `health.log`, `backup.log`

### Email Notification Monitoring

Email notifications are sent via Django signals for:
- New support tickets (to client and admin)
- Ticket resolutions (to client)
- New invoices (to client)
- Workflow errors (to admin)

**Test email configuration:**

```bash
docker compose exec django python manage.py shell

# In shell:
>>> from django.core.mail import send_mail
>>> send_mail(
...     'Test Email',
...     'Testing email configuration',
...     'noreply@monoliet.cloud',
...     ['your-email@example.com'],
... )
1
>>> exit()
```

**Based on:** clients/signals.py, portal/settings.py:175-181

### Performance Monitoring (Optional)

**Recommended tools:**
- **Sentry** - Error tracking and performance monitoring
- **New Relic** - Application performance monitoring
- **Datadog** - Infrastructure and application monitoring

**To add Sentry:**

1. Add to `requirements.txt`:
   ```
   sentry-sdk==1.40.0
   ```

2. Configure in `portal/settings.py`:
   ```python
   import sentry_sdk
   from sentry_sdk.integrations.django import DjangoIntegration

   sentry_sdk.init(
       dsn="your-sentry-dsn",
       integrations=[DjangoIntegration()],
       environment="production",
   )
   ```

---

## Backup Strategy

### Database Backups

**Manual Backup:**

```bash
# Create backup directory
mkdir -p /opt/monoliet-portal/backups

# Backup database
docker compose exec postgres pg_dump -U monoliet monoliet_clients > backups/backup_$(date +%Y%m%d_%H%M%S).sql
```

**Automated Backup Script:**

Create `/opt/monoliet-portal/scripts/backup_database.sh`:

```bash
#!/bin/bash

BACKUP_DIR="/opt/monoliet-portal/backups"
DATE=$(date +%Y%m%d_%H%M%S)
BACKUP_FILE="$BACKUP_DIR/monoliet_backup_$DATE.sql"
RETENTION_DAYS=30

# Create backup directory if it doesn't exist
mkdir -p $BACKUP_DIR

# Create backup
cd /opt/monoliet-portal
docker compose exec -T postgres pg_dump -U monoliet monoliet_clients > $BACKUP_FILE

# Compress backup
gzip $BACKUP_FILE

# Remove old backups
find $BACKUP_DIR -name "monoliet_backup_*.sql.gz" -mtime +$RETENTION_DAYS -delete

echo "Backup completed: $BACKUP_FILE.gz"
```

Make it executable:

```bash
chmod +x /opt/monoliet-portal/scripts/backup_database.sh
```

**Based on:** docker-compose.yml:4-20

### Restore from Backup

```bash
# Stop Django container
docker compose stop django

# Restore database
gunzip -c backups/monoliet_backup_20240117_030000.sql.gz | docker compose exec -T postgres psql -U monoliet monoliet_clients

# Restart Django
docker compose start django
```

### Application Backup

**Files to backup:**
- `/opt/monoliet-portal/.env` (environment variables)
- `/opt/monoliet-portal/postgres/data` (database volume)
- `/opt/monoliet-portal/media` (uploaded files, if any)

**Backup to remote storage:**

```bash
# Using rsync to remote server
rsync -avz --delete /opt/monoliet-portal/backups/ user@backup-server:/backups/monoliet/

# Or using rclone to cloud storage (S3, Google Drive, etc.)
rclone sync /opt/monoliet-portal/backups/ remote:monoliet-backups/
```

---

## Troubleshooting

### Container Issues

**Container not starting:**

```bash
# Check container status
docker compose ps

# View detailed logs
docker compose logs django

# Restart containers
docker compose restart

# Rebuild and restart
docker compose down
docker compose up -d --build
```

**Database connection errors:**

```bash
# Check PostgreSQL is running
docker compose ps postgres

# Verify database credentials in .env
cat .env | grep DB_

# Check PostgreSQL logs
docker compose logs postgres

# Restart PostgreSQL
docker compose restart postgres
```

**Based on:** README.md:263-270

### Static Files Not Loading

```bash
# Recollect static files
docker compose exec django python manage.py collectstatic --noinput --clear

# Verify WhiteNoise configuration
docker compose exec django python manage.py check --deploy
```

**Based on:** README.md:273-275, portal/settings.py:143-145

### Permission Issues

```bash
# Fix file ownership
sudo chown -R $USER:$USER /opt/monoliet-portal

# Fix container permissions (if needed)
docker compose exec -u root django chown -R django:django /app
```

**Based on:** README.md:278-281

### Email Not Sending

**Check SMTP configuration:**

```bash
# Test email from Django shell
docker compose exec django python manage.py shell

>>> from django.core.mail import send_mail
>>> send_mail('Test', 'Testing', 'noreply@monoliet.cloud', ['test@example.com'])
```

**Common issues:**
- Invalid Google App Password (generate new one)
- `EMAIL_USE_TLS` should be `True` for Gmail
- Port 587 must be accessible from server
- Check spam folder for test emails

**Based on:** portal/settings.py:175-181

### n8n Integration Issues

**Verify n8n API connection:**

```bash
docker compose exec django python manage.py shell

>>> from clients.utils import N8NAPIClient
>>> client = N8NAPIClient()
>>> workflows = client.get_workflows()
>>> len(workflows)
```

**Common issues:**
- Invalid `N8N_API_KEY` (check n8n settings)
- `N8N_URL` incorrect (should end without trailing slash)
- Network connectivity (firewall blocking outbound HTTPS)

**Based on:** clients/utils.py:94-221

### High Memory Usage

**Check container resource usage:**

```bash
docker stats
```

**Optimize Django:**
- Reduce Gunicorn workers (edit docker-compose.yml:26)
- Enable database connection pooling
- Implement caching (Redis)

**Based on:** docker-compose.yml:26

### Deployment Checklist Debug

```bash
# Run Django deployment check
docker compose exec django python manage.py check --deploy

# This will warn about:
# - DEBUG=True in production
# - Missing security headers
# - Insecure settings
```

**Based on:** Django deployment checklist

---

## Scaling Considerations

### Horizontal Scaling

**To handle more traffic:**

1. **Add more Gunicorn workers:**

   Edit `docker-compose.yml`:
   ```yaml
   command: gunicorn portal.wsgi:application --bind 0.0.0.0:8000 --workers 5
   ```

   Rule of thumb: `(2 x CPU_cores) + 1`

   **Based on:** docker-compose.yml:26

2. **Deploy multiple Django containers:**

   Use Docker Swarm or Kubernetes for orchestration.

3. **Add load balancer:**

   Configure Nginx Proxy Manager or HAProxy to distribute traffic across multiple Django instances.

### Database Scaling

**For larger datasets:**

1. **Enable connection pooling** (pgBouncer)
2. **Add read replicas** for read-heavy workloads
3. **Upgrade PostgreSQL instance** (more CPU/RAM)
4. **Implement caching layer** (Redis)

### Caching

**Add Redis for caching:**

1. Add to `docker-compose.yml`:
   ```yaml
   redis:
     image: redis:7-alpine
     restart: unless-stopped
     networks:
       - web
   ```

2. Add to `requirements.txt`:
   ```
   django-redis==5.4.0
   ```

3. Configure in `portal/settings.py`:
   ```python
   CACHES = {
       "default": {
           "BACKEND": "django_redis.cache.RedisCache",
           "LOCATION": "redis://redis:6379/1",
       }
   }
   ```

### CDN for Static Files

For better performance, serve static files via CDN:

1. Upload static files to S3/CloudFront
2. Update `STATIC_URL` in settings
3. Configure WhiteNoise to use CDN

---

## Security Best Practices

### Production Security Checklist

- [x] `DEBUG=False` in `.env`
- [x] Strong `SECRET_KEY` (50+ characters)
- [x] Strong database password
- [x] HTTPS enforced (via Nginx Proxy Manager)
- [x] `SECURE_SSL_REDIRECT=True` (auto-enabled when DEBUG=False)
- [x] HSTS enabled (via Nginx Proxy Manager SSL settings)
- [x] Regular security updates (`docker compose pull` periodically)
- [x] Firewall configured (UFW allowing only 80, 443, SSH)
- [x] Database not exposed to internet (internal Docker network only)
- [ ] Consider adding fail2ban for SSH protection
- [ ] Set up automated security scanning (Trivy, Snyk)
- [ ] Regular backup testing
- [ ] Implement rate limiting (optional)

**Based on:** portal/settings.py:197-207

### Regular Maintenance

**Weekly:**
- Review application logs for errors
- Check disk space usage
- Verify backups are being created

**Monthly:**
- Update Docker images: `docker compose pull && docker compose up -d`
- Review and update dependencies in `requirements.txt`
- Test backup restoration process
- Review user access and permissions

**Quarterly:**
- Update Django to latest LTS version
- Review and update all dependencies
- Security audit of custom code
- Performance optimization review

---

## Rollback Procedure

If deployment fails or issues occur in production:

### Quick Rollback

**1. Revert to previous Docker image:**

```bash
# Stop current deployment
docker compose down

# Checkout previous commit
git checkout <previous-commit-hash>

# Rebuild and deploy
docker compose up -d --build
```

**2. Restore database from backup:**

```bash
# Stop Django
docker compose stop django

# Restore database
gunzip -c backups/monoliet_backup_<timestamp>.sql.gz | docker compose exec -T postgres psql -U monoliet monoliet_clients

# Start Django
docker compose start django
```

**3. Verify application:**

```bash
# Check logs
docker compose logs -f django

# Test admin panel
curl -I https://portal.monoliet.cloud/admin/

# Test API
curl -I https://portal.monoliet.cloud/api/
```

---

## Support and Resources

### Documentation

- [README.md](README.md) - Quick start guide
- [ARCHITECTURE.md](ARCHITECTURE.md) - System architecture
- [API_REFERENCE.md](API_REFERENCE.md) - API documentation
- [CONTRIBUTING.md](CONTRIBUTING.md) - Development guide

### Getting Help

- **Email:** info@monoliet.cloud
- **Issues:** GitHub issue tracker
- **Logs:** Check application and cron logs first

---

**Last Updated:** 2026-01-17
**Django Version:** 5.0.1
**Python Version:** 3.11
**PostgreSQL Version:** 15
