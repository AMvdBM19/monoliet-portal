# Contributing to Monoliet Client Portal

<!-- Generated by Claude Code on 2026-01-17 - Based on repository analysis -->

Thank you for your interest in contributing to the Monoliet Client Portal! This document provides guidelines and instructions for developers who want to contribute to the project.

## Table of Contents

1. [Getting Started](#getting-started)
2. [Development Environment Setup](#development-environment-setup)
3. [Project Structure](#project-structure)
4. [Code Style Guidelines](#code-style-guidelines)
5. [Development Workflow](#development-workflow)
6. [Testing](#testing)
7. [Database Migrations](#database-migrations)
8. [Commit Guidelines](#commit-guidelines)
9. [Pull Request Process](#pull-request-process)
10. [Common Development Tasks](#common-development-tasks)

---

## Getting Started

### Prerequisites

Before you begin, ensure you have the following installed:

- **Docker** (version 20.10+)
- **Docker Compose** (version 2.0+)
- **Git**
- **Python 3.11** (for local development without Docker)
- **PostgreSQL 15** (for local development without Docker)

**Based on:** Dockerfile:1, docker-compose.yml:5, requirements.txt

### Fork and Clone

1. Fork the repository to your GitHub account
2. Clone your fork locally:

```bash
git clone https://github.com/YOUR_USERNAME/monoliet-portal.git
cd monoliet-portal
```

---

## Development Environment Setup

### Using Docker (Recommended)

**1. Create environment file:**

```bash
cp .env.example .env
```

**2. Configure environment variables:**

Edit `.env` and set the following (minimum required for development):

```env
# Django Settings
SECRET_KEY=dev-secret-key-change-this
DEBUG=True
ALLOWED_HOSTS=localhost,127.0.0.1

# Database
DB_NAME=monoliet_clients
DB_USER=monoliet
DB_PASSWORD=dev_password_123
DB_HOST=postgres
DB_PORT=5432

# Email (use console backend for development)
EMAIL_BACKEND=django.core.mail.backends.console.EmailBackend

# n8n Integration (optional for development)
N8N_URL=https://n8n.monoliet.cloud
N8N_API_KEY=

# Encryption Key (generate one)
ENCRYPTION_KEY=
```

**3. Generate encryption key:**

```bash
python -c "from cryptography.fernet import Fernet; print(Fernet.generate_key().decode())"
```

Add the output to `ENCRYPTION_KEY` in `.env`

**Based on:** .env.example:1-36

**4. Build and start containers:**

```bash
docker-compose up -d
```

**Based on:** docker-compose.yml

**5. Run database migrations:**

```bash
docker-compose exec django python manage.py migrate
```

**6. Create a superuser account:**

```bash
docker-compose exec django python manage.py createsuperuser
```

**7. Create sample data (optional):**

```bash
docker-compose exec django python manage.py create_sample_data
```

**8. Access the application:**

- **Web Portal:** http://localhost:8000/
- **Admin Panel:** http://localhost:8000/admin
- **API Root:** http://localhost:8000/api/

### Using Local Python Environment

**1. Create virtual environment:**

```bash
python3.11 -m venv venv
source venv/bin/activate  # On Windows: venv\Scripts\activate
```

**2. Install dependencies:**

```bash
pip install -r requirements.txt
```

**Based on:** requirements.txt

**3. Set up PostgreSQL:**

Create a database named `monoliet_clients` and configure `.env` with your local PostgreSQL credentials.

**4. Run migrations:**

```bash
python manage.py migrate
```

**5. Create superuser:**

```bash
python manage.py createsuperuser
```

**6. Run development server:**

```bash
python manage.py runserver
```

---

## Project Structure

```
monoliet-portal/
├── portal/                      # Django project settings
│   ├── settings.py             # Main configuration
│   ├── urls.py                 # Root URL routing
│   └── wsgi.py                 # WSGI application
│
├── clients/                     # Main application
│   ├── models.py               # Database models (8 models)
│   ├── views.py                # API views (DRF ViewSets)
│   ├── web_views.py            # Web interface views
│   ├── serializers.py          # DRF serializers
│   ├── permissions.py          # Custom permission classes
│   ├── admin.py                # Admin site configuration
│   ├── admin_views.py          # Custom admin views
│   ├── signals.py              # Email notification triggers
│   ├── forms.py                # Django forms
│   ├── utils.py                # Utility functions
│   ├── urls.py                 # API URL routing
│   ├── web_urls.py             # Web interface URL routing
│   │
│   ├── templates/              # HTML templates
│   │   ├── admin/             # Admin customizations
│   │   └── clients/           # Client portal templates
│   │
│   └── management/commands/    # Management commands
│       ├── sync_n8n_executions.py
│       ├── send_invoice_reminders.py
│       ├── check_workflow_health.py
│       └── create_sample_data.py
│
├── staticfiles/                # Collected static files (generated)
├── postgres/                   # PostgreSQL data volume (git-ignored)
│
├── requirements.txt            # Python dependencies
├── docker-compose.yml          # Docker services
├── Dockerfile                  # Django container
├── .env.example                # Environment variable template
├── .gitignore                  # Git ignore rules
└── manage.py                   # Django management script
```

**Based on:** Actual repository structure

---

## Code Style Guidelines

### Python Code Style

The project follows Django and Python best practices. While there's no enforced linter configuration yet, please adhere to these guidelines:

**1. PEP 8 Compliance**
- Use 4 spaces for indentation (not tabs)
- Maximum line length: 100 characters (Django preference)
- Use snake_case for functions and variables
- Use PascalCase for class names

**2. Django Conventions**
- Models: Singular noun (e.g., `Client`, not `Clients`)
- Apps: Plural noun (e.g., `clients`)
- View classes: Descriptive names ending with purpose (e.g., `ClientViewSet`, `DashboardView`)

**3. Imports**
- Group imports: standard library, third-party, local
- Use absolute imports
- Example from models.py:1-12:

```python
"""
Module docstring
"""

import uuid
from django.db import models
from django.contrib.auth.models import User
from django.core.validators import MinValueValidator
from decimal import Decimal
```

**Based on:** clients/models.py:1-12

**4. Docstrings**
- Use triple-quoted docstrings for modules, classes, and functions
- Example from models.py:15-20:

```python
class Client(models.Model):
    """
    Represents a client company that uses Monoliet's n8n automation services.

    Each client has a plan tier, billing information, and status tracking.
    """
```

**Based on:** clients/models.py:15-20

**5. Type Hints**
- Use type hints for utility functions (see clients/utils.py)
- Example from utils.py:17-29:

```python
def encrypt_credential(data: dict) -> str:
    """
    Encrypt credential data using Fernet symmetric encryption.

    Args:
        data: Dictionary containing credential information

    Returns:
        Encrypted string representation of the data
    """
```

**Based on:** clients/utils.py:17-29

### HTML/Template Style

**1. Template Structure**
- Use Django template inheritance
- Base template: `clients/templates/clients/base.html`
- Block names: `title`, `content`, `extra_css`, `extra_js`

**2. Tailwind CSS**
- Use Tailwind utility classes (loaded via CDN)
- Responsive design: mobile-first approach
- Example classes: `container`, `mx-auto`, `p-6`, `bg-white`, `rounded-lg`

**Based on:** clients/templates/clients/base.html

### JavaScript Style

**1. Minimal JavaScript**
- Prefer server-side rendering
- Use vanilla JavaScript (no framework requirements)
- Keep scripts inline in templates when simple

---

## Development Workflow

### 1. Create a Feature Branch

```bash
git checkout -b feature/your-feature-name
```

Or for bug fixes:

```bash
git checkout -b fix/issue-description
```

### 2. Make Your Changes

- Write clean, well-documented code
- Follow the code style guidelines
- Add docstrings to new functions/classes
- Update relevant documentation

### 3. Test Your Changes

**Run the development server:**
```bash
docker-compose up
```

**Check for errors in logs:**
```bash
docker-compose logs -f django
```

**Test API endpoints:**
```bash
# Example: Test authentication
curl -X POST http://localhost:8000/api/auth/token/ \
  -H "Content-Type: application/json" \
  -d '{"username":"admin","password":"your_password"}'
```

### 4. Create Migrations (if models changed)

```bash
docker-compose exec django python manage.py makemigrations
docker-compose exec django python manage.py migrate
```

**Based on:** README.md:238-242

### 5. Run Tests

```bash
docker-compose exec django python manage.py test
```

**Based on:** README.md:234-236

---

## Testing

### Running Tests

**All tests:**
```bash
docker-compose exec django python manage.py test
```

**Specific app:**
```bash
docker-compose exec django python manage.py test clients
```

**Specific test class:**
```bash
docker-compose exec django python manage.py test clients.tests.ClientModelTestCase
```

**With verbosity:**
```bash
docker-compose exec django python manage.py test --verbosity=2
```

### Writing Tests

Tests should be placed in `clients/tests.py` or `clients/tests/` directory.

**Example Test Structure:**

```python
from django.test import TestCase
from django.contrib.auth.models import User
from clients.models import Client

class ClientModelTestCase(TestCase):
    def setUp(self):
        """Set up test data."""
        self.client = Client.objects.create(
            company_name="Test Corp",
            contact_name="Test User",
            email="test@example.com",
            plan_tier="Basic",
            setup_fee=100.00,
            monthly_fee=50.00,
            next_billing_date="2024-12-31"
        )

    def test_client_creation(self):
        """Test client is created correctly."""
        self.assertEqual(self.client.company_name, "Test Corp")
        self.assertEqual(self.client.status, "active")

    def test_client_string_representation(self):
        """Test __str__ method."""
        expected = "Test Corp (Test User)"
        self.assertEqual(str(self.client), expected)
```

**Based on:** Django testing best practices

---

## Database Migrations

### Creating Migrations

**After modifying models:**

```bash
docker-compose exec django python manage.py makemigrations
```

This generates migration files in `clients/migrations/`

**Based on:** clients/models.py

### Applying Migrations

```bash
docker-compose exec django python manage.py migrate
```

### Checking Migration Status

```bash
docker-compose exec django python manage.py showmigrations
```

### Reverting Migrations

```bash
# Revert to specific migration
docker-compose exec django python manage.py migrate clients 0001_initial

# Revert all migrations for an app
docker-compose exec django python manage.py migrate clients zero
```

### Migration Best Practices

1. **Review generated migrations** before committing
2. **Never edit applied migrations** in production
3. **Create data migrations** for complex data transformations
4. **Test migrations** on a copy of production data before deploying

---

## Commit Guidelines

### Commit Message Format

```
<type>: <subject>

<body (optional)>
```

### Commit Types

- `feat`: New feature
- `fix`: Bug fix
- `docs`: Documentation changes
- `style`: Code style changes (formatting, no logic change)
- `refactor`: Code refactoring
- `test`: Adding or updating tests
- `chore`: Maintenance tasks, dependency updates

### Examples

**Good commit messages:**

```
feat: Add invoice PDF download endpoint

Implements PDF generation for invoices using ReportLab.
Adds new endpoint at /api/invoices/{id}/download/
```

```
fix: Resolve workflow activation permission issue

Client users were incorrectly denied access to view workflow status.
Updated IsClientOwner permission to allow read-only access.
```

```
docs: Update API reference with new endpoints

Added documentation for:
- Workflow activation endpoint
- Execution statistics endpoint
```

**Bad commit messages:**

```
Update stuff
```

```
Fixed bug
```

```
WIP
```

---

## Pull Request Process

### Before Submitting

1. ✅ Ensure code follows style guidelines
2. ✅ Add/update docstrings
3. ✅ Create/update tests
4. ✅ Run tests locally and verify they pass
5. ✅ Update documentation if needed
6. ✅ Create database migrations if models changed
7. ✅ Test migrations work correctly
8. ✅ Rebase on latest `master` branch

### Submitting a Pull Request

1. **Push your branch to GitHub:**

```bash
git push origin feature/your-feature-name
```

2. **Create PR on GitHub:**
   - Go to the repository on GitHub
   - Click "New Pull Request"
   - Select your branch
   - Fill out the PR template

3. **PR Title Format:**

```
[Type] Short description of changes
```

Examples:
- `[Feature] Add invoice PDF generation`
- `[Fix] Resolve permission issue in workflow API`
- `[Docs] Update deployment guide`

4. **PR Description Should Include:**
   - Summary of changes
   - Motivation/context
   - Related issues (if any)
   - Testing performed
   - Screenshots (if UI changes)
   - Breaking changes (if any)

### PR Review Process

1. **Automated checks** (if configured):
   - Code quality
   - Tests passing
   - No merge conflicts

2. **Manual review:**
   - Code review by maintainer
   - Feedback and requested changes
   - Approval

3. **Merge:**
   - Squash and merge (preferred)
   - Update CHANGELOG.md if significant feature

---

## Common Development Tasks

### Adding a New Model

**1. Define model in `clients/models.py`:**

```python
class NewModel(models.Model):
    """Model description."""
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    # ... fields ...
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        ordering = ['-created_at']
        verbose_name = 'New Model'
        verbose_name_plural = 'New Models'

    def __str__(self):
        return f"NewModel {self.id}"
```

**Based on:** clients/models.py pattern

**2. Create serializer in `clients/serializers.py`:**

```python
class NewModelSerializer(serializers.ModelSerializer):
    """Serializer for NewModel."""

    class Meta:
        model = NewModel
        fields = ['id', 'field1', 'field2', 'created_at', 'updated_at']
        read_only_fields = ['id', 'created_at', 'updated_at']
```

**Based on:** clients/serializers.py pattern

**3. Create ViewSet in `clients/views.py`:**

```python
class NewModelViewSet(viewsets.ModelViewSet):
    """ViewSet for NewModel."""
    queryset = NewModel.objects.all()
    serializer_class = NewModelSerializer
    permission_classes = [IsAdminUser]
```

**Based on:** clients/views.py pattern

**4. Register in `clients/admin.py`:**

```python
@admin.register(NewModel)
class NewModelAdmin(admin.ModelAdmin):
    list_display = ['id', 'field1', 'field2', 'created_at']
    search_fields = ['field1', 'field2']
```

**Based on:** clients/admin.py pattern

**5. Add to API URLs in `clients/urls.py`:**

```python
router.register(r'new-models', views.NewModelViewSet, basename='newmodel')
```

**6. Create and run migrations:**

```bash
docker-compose exec django python manage.py makemigrations
docker-compose exec django python manage.py migrate
```

### Adding a New API Endpoint

**1. Add custom action to ViewSet:**

```python
from rest_framework.decorators import action

class ClientViewSet(viewsets.ModelViewSet):
    # ... existing code ...

    @action(detail=True, methods=['post'])
    def custom_action(self, request, pk=None):
        """Custom action description."""
        obj = self.get_object()
        # ... logic ...
        serializer = self.get_serializer(obj)
        return Response(serializer.data)
```

**Based on:** clients/views.py:81-97, 136-151

**2. Update API documentation in API_REFERENCE.md**

### Adding Email Notifications

**1. Create signal handler in `clients/signals.py`:**

```python
from django.db.models.signals import post_save
from django.dispatch import receiver
from django.core.mail import send_mail

@receiver(post_save, sender=NewModel)
def send_notification_on_create(sender, instance, created, **kwargs):
    """Send email when NewModel is created."""
    if created:
        send_mail(
            subject='New Model Created',
            message=f'NewModel {instance.id} was created.',
            from_email='noreply@monoliet.cloud',
            recipient_list=['admin@monoliet.cloud'],
            fail_silently=False,
        )
```

**Based on:** clients/signals.py pattern

**2. Import signals in `clients/__init__.py`:**

```python
default_app_config = 'clients.apps.ClientsConfig'
```

And in `clients/apps.py`:

```python
def ready(self):
    import clients.signals
```

### Adding a Management Command

**1. Create file in `clients/management/commands/`:**

```bash
touch clients/management/commands/your_command.py
```

**2. Implement command:**

```python
from django.core.management.base import BaseCommand

class Command(BaseCommand):
    help = 'Description of what this command does'

    def add_arguments(self, parser):
        parser.add_argument(
            '--option',
            type=str,
            help='Optional argument description',
        )

    def handle(self, *args, **options):
        """Execute command logic."""
        self.stdout.write(self.style.SUCCESS('Command executed successfully'))
```

**Based on:** clients/management/commands/ pattern

**3. Run command:**

```bash
docker-compose exec django python manage.py your_command --option=value
```

### Debugging

**1. View Django logs:**

```bash
docker-compose logs -f django
```

**2. Access Django shell:**

```bash
docker-compose exec django python manage.py shell
```

Example usage:

```python
from clients.models import Client
clients = Client.objects.all()
for client in clients:
    print(client.company_name)
```

**3. Access PostgreSQL:**

```bash
docker-compose exec postgres psql -U monoliet -d monoliet_clients
```

**4. Enable Django Debug Toolbar (optional):**

Add to `requirements.txt`:
```
django-debug-toolbar==4.2.0
```

Configure in `settings.py` when `DEBUG=True`.

---

## Environment Variables

All environment variables are defined in `.env` file (git-ignored).

**Required Variables:**
- `SECRET_KEY` - Django secret key
- `DEBUG` - Debug mode (True/False)
- `ALLOWED_HOSTS` - Comma-separated hostnames
- `DB_NAME`, `DB_USER`, `DB_PASSWORD`, `DB_HOST`, `DB_PORT` - Database config
- `ENCRYPTION_KEY` - Fernet encryption key

**Optional Variables:**
- `EMAIL_HOST`, `EMAIL_PORT`, `EMAIL_HOST_USER`, `EMAIL_HOST_PASSWORD` - Email config
- `N8N_URL`, `N8N_API_KEY` - n8n integration
- `CSRF_TRUSTED_ORIGINS` - Trusted origins for CSRF

**See:** .env.example for complete list with descriptions

**Based on:** .env.example:1-36, portal/settings.py

---

## Security Considerations

### Do NOT Commit

- `.env` files (git-ignored)
- Database credentials
- API keys
- Secret keys
- `postgres/` data directory (git-ignored)

**Based on:** .gitignore:34-50

### Best Practices

1. **Always use environment variables** for sensitive data
2. **Never hardcode credentials** in code
3. **Use encrypted storage** for API credentials (see `clients/utils.py:encrypt_credential`)
4. **Validate user input** in serializers
5. **Use Django ORM** (prevents SQL injection)
6. **Enable HTTPS** in production
7. **Keep dependencies updated**

**Based on:** clients/utils.py:17-62, portal/settings.py:197-207

---

## Additional Resources

### Documentation

- [Django Documentation](https://docs.djangoproject.com/en/5.0/)
- [Django REST Framework](https://www.django-rest-framework.org/)
- [PostgreSQL Documentation](https://www.postgresql.org/docs/15/)
- [Docker Documentation](https://docs.docker.com/)

### Project Documentation

- [README.md](README.md) - Project overview and setup
- [ARCHITECTURE.md](ARCHITECTURE.md) - System architecture
- [API_REFERENCE.md](API_REFERENCE.md) - Complete API documentation
- [SETUP_GUIDE.md](SETUP_GUIDE.md) - Detailed setup instructions

---

## Getting Help

If you have questions or need help:

1. **Check existing documentation** (README, ARCHITECTURE, API_REFERENCE)
2. **Search closed issues** on GitHub
3. **Ask in discussions** (if enabled)
4. **Create an issue** for bugs or feature requests
5. **Email:** info@monoliet.cloud

---

## License

Proprietary - Monoliet.cloud

All contributions will be subject to the same license.

---

**Last Updated:** 2026-01-17
**Django Version:** 5.0.1
**Python Version:** 3.11
